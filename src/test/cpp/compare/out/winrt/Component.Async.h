// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.000000.0
#ifndef WINRT_Component_Async_H
#define WINRT_Component_Async_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.000000.0"), "Mismatched C++/WinRT headers.");
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Component.Async.2.h"
#include "winrt/Component.h"
namespace winrt::impl
{
    template <typename D> Windows::Foundation::IAsyncAction consume_Component_Async_IClassStatics<D>::Action() const
    {
        void* operation;
        check_hresult(WINRT_SHIM(Component::Async::IClassStatics)->Action(&operation));
        return { operation, take_ownership_from_abi };
    }
    template <typename D> Windows::Foundation::IAsyncActionWithProgress<int32_t> consume_Component_Async_IClassStatics<D>::ActionWithProgress() const
    {
        void* operation;
        check_hresult(WINRT_SHIM(Component::Async::IClassStatics)->ActionWithProgress(&operation));
        return { operation, take_ownership_from_abi };
    }
    template <typename D> Windows::Foundation::IAsyncOperation<hstring> consume_Component_Async_IClassStatics<D>::Operation() const
    {
        void* operation;
        check_hresult(WINRT_SHIM(Component::Async::IClassStatics)->Operation(&operation));
        return { operation, take_ownership_from_abi };
    }
    template <typename D> Windows::Foundation::IAsyncOperationWithProgress<hstring, int32_t> consume_Component_Async_IClassStatics<D>::OperationWithProgress() const
    {
        void* operation;
        check_hresult(WINRT_SHIM(Component::Async::IClassStatics)->OperationWithProgress(&operation));
        return { operation, take_ownership_from_abi };
    }
    template <typename D>
    struct produce<D, Component::Async::IClassStatics> : produce_base<D, Component::Async::IClassStatics>
    {
        int32_t WINRT_CALL Action(void** operation) noexcept final
        {
            try
            {
                *operation = nullptr;
                typename D::abi_guard guard(this->shim());
                *operation = detach_from<Windows::Foundation::IAsyncAction>(this->shim().Action());
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
        int32_t WINRT_CALL ActionWithProgress(void** operation) noexcept final
        {
            try
            {
                *operation = nullptr;
                typename D::abi_guard guard(this->shim());
                *operation = detach_from<Windows::Foundation::IAsyncActionWithProgress<int32_t>>(this->shim().ActionWithProgress());
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
        int32_t WINRT_CALL Operation(void** operation) noexcept final
        {
            try
            {
                *operation = nullptr;
                typename D::abi_guard guard(this->shim());
                *operation = detach_from<Windows::Foundation::IAsyncOperation<hstring>>(this->shim().Operation());
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
        int32_t WINRT_CALL OperationWithProgress(void** operation) noexcept final
        {
            try
            {
                *operation = nullptr;
                typename D::abi_guard guard(this->shim());
                *operation = detach_from<Windows::Foundation::IAsyncOperationWithProgress<hstring, int32_t>>(this->shim().OperationWithProgress());
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
    };
}
namespace winrt::Component::Async
{
    inline Windows::Foundation::IAsyncAction Class::Action()
    {
        return impl::call_factory<Class, Component::Async::IClassStatics>([&](auto&& f) { return f.Action(); });
    }
    inline Windows::Foundation::IAsyncActionWithProgress<int32_t> Class::ActionWithProgress()
    {
        return impl::call_factory<Class, Component::Async::IClassStatics>([&](auto&& f) { return f.ActionWithProgress(); });
    }
    inline Windows::Foundation::IAsyncOperation<hstring> Class::Operation()
    {
        return impl::call_factory<Class, Component::Async::IClassStatics>([&](auto&& f) { return f.Operation(); });
    }
    inline Windows::Foundation::IAsyncOperationWithProgress<hstring, int32_t> Class::OperationWithProgress()
    {
        return impl::call_factory<Class, Component::Async::IClassStatics>([&](auto&& f) { return f.OperationWithProgress(); });
    }
}
namespace std
{
    template<> struct hash<winrt::Component::Async::IClassStatics> : winrt::impl::hash_base<winrt::Component::Async::IClassStatics> {};
    template<> struct hash<winrt::Component::Async::Class> : winrt::impl::hash_base<winrt::Component::Async::Class> {};
}
#endif
