// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.000000.0
#ifndef WINRT_HEADER_Component_Edge_0
#define WINRT_HEADER_Component_Edge_0
#include "winrt/base.h"
namespace winrt::Component::Edge
{
    struct IEmptyClass;
    struct IOneClass;
    struct IOneClassFactory;
    struct IOneClassStatics;
    struct IStaticClassStatics;
    struct IThreeClass;
    struct IThreeClassFactory;
    struct IThreeClassStatics;
    struct ITwoClass;
    struct ITwoClassFactory;
    struct ITwoClassStatics;
    struct IZeroClass;
    struct IZeroClassStatics;
    struct EmptyClass;
    struct OneClass;
    struct StaticClass;
    struct ThreeClass;
    struct TwoClass;
    struct ZeroClass;
}
namespace winrt::impl
{
    template <> struct category<Component::Edge::IEmptyClass>
    {
        using type = interface_category;
    };
    template <> struct category<Component::Edge::IOneClass>
    {
        using type = interface_category;
    };
    template <> struct category<Component::Edge::IOneClassFactory>
    {
        using type = interface_category;
    };
    template <> struct category<Component::Edge::IOneClassStatics>
    {
        using type = interface_category;
    };
    template <> struct category<Component::Edge::IStaticClassStatics>
    {
        using type = interface_category;
    };
    template <> struct category<Component::Edge::IThreeClass>
    {
        using type = interface_category;
    };
    template <> struct category<Component::Edge::IThreeClassFactory>
    {
        using type = interface_category;
    };
    template <> struct category<Component::Edge::IThreeClassStatics>
    {
        using type = interface_category;
    };
    template <> struct category<Component::Edge::ITwoClass>
    {
        using type = interface_category;
    };
    template <> struct category<Component::Edge::ITwoClassFactory>
    {
        using type = interface_category;
    };
    template <> struct category<Component::Edge::ITwoClassStatics>
    {
        using type = interface_category;
    };
    template <> struct category<Component::Edge::IZeroClass>
    {
        using type = interface_category;
    };
    template <> struct category<Component::Edge::IZeroClassStatics>
    {
        using type = interface_category;
    };
    template <> struct category<Component::Edge::EmptyClass>
    {
        using type = class_category;
    };
    template <> struct category<Component::Edge::OneClass>
    {
        using type = class_category;
    };
    template <> struct category<Component::Edge::StaticClass>
    {
        using type = class_category;
    };
    template <> struct category<Component::Edge::ThreeClass>
    {
        using type = class_category;
    };
    template <> struct category<Component::Edge::TwoClass>
    {
        using type = class_category;
    };
    template <> struct category<Component::Edge::ZeroClass>
    {
        using type = class_category;
    };
    template <> struct name<Component::Edge::IEmptyClass>
    {
        static constexpr auto & value{ L"Component.Edge.IEmptyClass" };
    };
    template <> struct name<Component::Edge::IOneClass>
    {
        static constexpr auto & value{ L"Component.Edge.IOneClass" };
    };
    template <> struct name<Component::Edge::IOneClassFactory>
    {
        static constexpr auto & value{ L"Component.Edge.IOneClassFactory" };
    };
    template <> struct name<Component::Edge::IOneClassStatics>
    {
        static constexpr auto & value{ L"Component.Edge.IOneClassStatics" };
    };
    template <> struct name<Component::Edge::IStaticClassStatics>
    {
        static constexpr auto & value{ L"Component.Edge.IStaticClassStatics" };
    };
    template <> struct name<Component::Edge::IThreeClass>
    {
        static constexpr auto & value{ L"Component.Edge.IThreeClass" };
    };
    template <> struct name<Component::Edge::IThreeClassFactory>
    {
        static constexpr auto & value{ L"Component.Edge.IThreeClassFactory" };
    };
    template <> struct name<Component::Edge::IThreeClassStatics>
    {
        static constexpr auto & value{ L"Component.Edge.IThreeClassStatics" };
    };
    template <> struct name<Component::Edge::ITwoClass>
    {
        static constexpr auto & value{ L"Component.Edge.ITwoClass" };
    };
    template <> struct name<Component::Edge::ITwoClassFactory>
    {
        static constexpr auto & value{ L"Component.Edge.ITwoClassFactory" };
    };
    template <> struct name<Component::Edge::ITwoClassStatics>
    {
        static constexpr auto & value{ L"Component.Edge.ITwoClassStatics" };
    };
    template <> struct name<Component::Edge::IZeroClass>
    {
        static constexpr auto & value{ L"Component.Edge.IZeroClass" };
    };
    template <> struct name<Component::Edge::IZeroClassStatics>
    {
        static constexpr auto & value{ L"Component.Edge.IZeroClassStatics" };
    };
    template <> struct name<Component::Edge::EmptyClass>
    {
        static constexpr auto & value{ L"Component.Edge.EmptyClass" };
    };
    template <> struct name<Component::Edge::OneClass>
    {
        static constexpr auto & value{ L"Component.Edge.OneClass" };
    };
    template <> struct name<Component::Edge::StaticClass>
    {
        static constexpr auto & value{ L"Component.Edge.StaticClass" };
    };
    template <> struct name<Component::Edge::ThreeClass>
    {
        static constexpr auto & value{ L"Component.Edge.ThreeClass" };
    };
    template <> struct name<Component::Edge::TwoClass>
    {
        static constexpr auto & value{ L"Component.Edge.TwoClass" };
    };
    template <> struct name<Component::Edge::ZeroClass>
    {
        static constexpr auto & value{ L"Component.Edge.ZeroClass" };
    };
    template <> struct guid_storage<Component::Edge::IEmptyClass>
    {
        static constexpr guid value{ 0x17AD6196,0xEC04,0x52E9,{ 0x80,0xBB,0xCE,0x7C,0xA3,0x86,0x0A,0xBD } };
    };
    template <> struct guid_storage<Component::Edge::IOneClass>
    {
        static constexpr guid value{ 0x0AEC35FD,0xB8C3,0x5CCE,{ 0xA5,0xE6,0xDB,0xE3,0x2E,0xE5,0x74,0xFA } };
    };
    template <> struct guid_storage<Component::Edge::IOneClassFactory>
    {
        static constexpr guid value{ 0x003BEA5B,0x2097,0x544A,{ 0xA3,0xF9,0xBC,0x7C,0x60,0x9E,0xC4,0xCB } };
    };
    template <> struct guid_storage<Component::Edge::IOneClassStatics>
    {
        static constexpr guid value{ 0xA51F0896,0x7611,0x5300,{ 0xBB,0x3D,0xB3,0x4C,0x8C,0x1D,0x0C,0x4E } };
    };
    template <> struct guid_storage<Component::Edge::IStaticClassStatics>
    {
        static constexpr guid value{ 0x8AFF23D6,0x5052,0x59D3,{ 0xBB,0x52,0x1C,0xC1,0xEF,0x32,0x87,0x3A } };
    };
    template <> struct guid_storage<Component::Edge::IThreeClass>
    {
        static constexpr guid value{ 0x76137452,0xDABD,0x5B5B,{ 0xBF,0x5A,0xC4,0xFE,0x9B,0xAA,0x13,0x2D } };
    };
    template <> struct guid_storage<Component::Edge::IThreeClassFactory>
    {
        static constexpr guid value{ 0x0BACC950,0x9873,0x598B,{ 0xB3,0xBA,0x96,0x94,0x59,0x07,0xD4,0x67 } };
    };
    template <> struct guid_storage<Component::Edge::IThreeClassStatics>
    {
        static constexpr guid value{ 0xDC9B7F7A,0xCDD7,0x5CC9,{ 0x9B,0x75,0x7D,0xE3,0xA1,0xDA,0xB2,0x6F } };
    };
    template <> struct guid_storage<Component::Edge::ITwoClass>
    {
        static constexpr guid value{ 0x836AFF4A,0x72B5,0x53C0,{ 0x88,0x78,0x35,0x94,0xB1,0xFB,0x14,0x4C } };
    };
    template <> struct guid_storage<Component::Edge::ITwoClassFactory>
    {
        static constexpr guid value{ 0x3A8244AF,0x2389,0x5482,{ 0xB6,0x13,0xC7,0xC1,0x4D,0x59,0x37,0x5F } };
    };
    template <> struct guid_storage<Component::Edge::ITwoClassStatics>
    {
        static constexpr guid value{ 0x7F995804,0x0803,0x582F,{ 0xB5,0x8C,0x3A,0x91,0x56,0x85,0xCF,0x71 } };
    };
    template <> struct guid_storage<Component::Edge::IZeroClass>
    {
        static constexpr guid value{ 0xC3624F52,0x87A8,0x5E4B,{ 0x85,0x29,0x12,0x5A,0x27,0x75,0xA1,0x53 } };
    };
    template <> struct guid_storage<Component::Edge::IZeroClassStatics>
    {
        static constexpr guid value{ 0xE1E63C69,0x8EB9,0x5B29,{ 0xA9,0x3A,0x5D,0x26,0x03,0xA6,0xF8,0xC4 } };
    };
    template <> struct default_interface<Component::Edge::EmptyClass>
    {
        using type = Component::Edge::IEmptyClass;
    };
    template <> struct default_interface<Component::Edge::OneClass>
    {
        using type = Component::Edge::IOneClass;
    };
    template <> struct default_interface<Component::Edge::ThreeClass>
    {
        using type = Component::Edge::IThreeClass;
    };
    template <> struct default_interface<Component::Edge::TwoClass>
    {
        using type = Component::Edge::ITwoClass;
    };
    template <> struct default_interface<Component::Edge::ZeroClass>
    {
        using type = Component::Edge::IZeroClass;
    };
    template <> struct abi<Component::Edge::IEmptyClass>
    {
        struct type : inspectable_abi
        {
        };
    };
    template <> struct abi<Component::Edge::IOneClass>
    {
        struct type : inspectable_abi
        {
            virtual int32_t WINRT_CALL Method(int32_t) noexcept = 0;
            virtual int32_t WINRT_CALL First(int32_t*) noexcept = 0;
        };
    };
    template <> struct abi<Component::Edge::IOneClassFactory>
    {
        struct type : inspectable_abi
        {
            virtual int32_t WINRT_CALL CreateInstance(int32_t, void**) noexcept = 0;
        };
    };
    template <> struct abi<Component::Edge::IOneClassStatics>
    {
        struct type : inspectable_abi
        {
            virtual int32_t WINRT_CALL StaticMethod(int32_t) noexcept = 0;
        };
    };
    template <> struct abi<Component::Edge::IStaticClassStatics>
    {
        struct type : inspectable_abi
        {
            virtual int32_t WINRT_CALL StaticMethod() noexcept = 0;
        };
    };
    template <> struct abi<Component::Edge::IThreeClass>
    {
        struct type : inspectable_abi
        {
            virtual int32_t WINRT_CALL Method(int32_t, int32_t, int32_t) noexcept = 0;
            virtual int32_t WINRT_CALL First(int32_t*) noexcept = 0;
            virtual int32_t WINRT_CALL Second(int32_t*) noexcept = 0;
            virtual int32_t WINRT_CALL Third(int32_t*) noexcept = 0;
        };
    };
    template <> struct abi<Component::Edge::IThreeClassFactory>
    {
        struct type : inspectable_abi
        {
            virtual int32_t WINRT_CALL CreateInstance(int32_t, int32_t, int32_t, void**) noexcept = 0;
        };
    };
    template <> struct abi<Component::Edge::IThreeClassStatics>
    {
        struct type : inspectable_abi
        {
            virtual int32_t WINRT_CALL StaticMethod(int32_t, int32_t, int32_t) noexcept = 0;
        };
    };
    template <> struct abi<Component::Edge::ITwoClass>
    {
        struct type : inspectable_abi
        {
            virtual int32_t WINRT_CALL Method(int32_t, int32_t) noexcept = 0;
            virtual int32_t WINRT_CALL First(int32_t*) noexcept = 0;
            virtual int32_t WINRT_CALL Second(int32_t*) noexcept = 0;
        };
    };
    template <> struct abi<Component::Edge::ITwoClassFactory>
    {
        struct type : inspectable_abi
        {
            virtual int32_t WINRT_CALL CreateInstance(int32_t, int32_t, void**) noexcept = 0;
        };
    };
    template <> struct abi<Component::Edge::ITwoClassStatics>
    {
        struct type : inspectable_abi
        {
            virtual int32_t WINRT_CALL StaticMethod(int32_t, int32_t) noexcept = 0;
        };
    };
    template <> struct abi<Component::Edge::IZeroClass>
    {
        struct type : inspectable_abi
        {
            virtual int32_t WINRT_CALL Method() noexcept = 0;
        };
    };
    template <> struct abi<Component::Edge::IZeroClassStatics>
    {
        struct type : inspectable_abi
        {
            virtual int32_t WINRT_CALL StaticMethod() noexcept = 0;
        };
    };
    template <typename D>
    struct consume_Component_Edge_IEmptyClass
    {
    };
    template <> struct consume<Component::Edge::IEmptyClass>
    {
        template <typename D> using type = consume_Component_Edge_IEmptyClass<D>;
    };
    template <typename D>
    struct consume_Component_Edge_IOneClass
    {
        void Method(int32_t a) const;
        int32_t First() const;
    };
    template <> struct consume<Component::Edge::IOneClass>
    {
        template <typename D> using type = consume_Component_Edge_IOneClass<D>;
    };
    template <typename D>
    struct consume_Component_Edge_IOneClassFactory
    {
        Component::Edge::OneClass CreateInstance(int32_t a) const;
    };
    template <> struct consume<Component::Edge::IOneClassFactory>
    {
        template <typename D> using type = consume_Component_Edge_IOneClassFactory<D>;
    };
    template <typename D>
    struct consume_Component_Edge_IOneClassStatics
    {
        void StaticMethod(int32_t a) const;
    };
    template <> struct consume<Component::Edge::IOneClassStatics>
    {
        template <typename D> using type = consume_Component_Edge_IOneClassStatics<D>;
    };
    template <typename D>
    struct consume_Component_Edge_IStaticClassStatics
    {
        void StaticMethod() const;
    };
    template <> struct consume<Component::Edge::IStaticClassStatics>
    {
        template <typename D> using type = consume_Component_Edge_IStaticClassStatics<D>;
    };
    template <typename D>
    struct consume_Component_Edge_IThreeClass
    {
        void Method(int32_t a, int32_t b, int32_t c) const;
        int32_t First() const;
        int32_t Second() const;
        int32_t Third() const;
    };
    template <> struct consume<Component::Edge::IThreeClass>
    {
        template <typename D> using type = consume_Component_Edge_IThreeClass<D>;
    };
    template <typename D>
    struct consume_Component_Edge_IThreeClassFactory
    {
        Component::Edge::ThreeClass CreateInstance(int32_t a, int32_t b, int32_t c) const;
    };
    template <> struct consume<Component::Edge::IThreeClassFactory>
    {
        template <typename D> using type = consume_Component_Edge_IThreeClassFactory<D>;
    };
    template <typename D>
    struct consume_Component_Edge_IThreeClassStatics
    {
        void StaticMethod(int32_t a, int32_t b, int32_t c) const;
    };
    template <> struct consume<Component::Edge::IThreeClassStatics>
    {
        template <typename D> using type = consume_Component_Edge_IThreeClassStatics<D>;
    };
    template <typename D>
    struct consume_Component_Edge_ITwoClass
    {
        void Method(int32_t a, int32_t b) const;
        int32_t First() const;
        int32_t Second() const;
    };
    template <> struct consume<Component::Edge::ITwoClass>
    {
        template <typename D> using type = consume_Component_Edge_ITwoClass<D>;
    };
    template <typename D>
    struct consume_Component_Edge_ITwoClassFactory
    {
        Component::Edge::TwoClass CreateInstance(int32_t a, int32_t b) const;
    };
    template <> struct consume<Component::Edge::ITwoClassFactory>
    {
        template <typename D> using type = consume_Component_Edge_ITwoClassFactory<D>;
    };
    template <typename D>
    struct consume_Component_Edge_ITwoClassStatics
    {
        void StaticMethod(int32_t a, int32_t b) const;
    };
    template <> struct consume<Component::Edge::ITwoClassStatics>
    {
        template <typename D> using type = consume_Component_Edge_ITwoClassStatics<D>;
    };
    template <typename D>
    struct consume_Component_Edge_IZeroClass
    {
        void Method() const;
    };
    template <> struct consume<Component::Edge::IZeroClass>
    {
        template <typename D> using type = consume_Component_Edge_IZeroClass<D>;
    };
    template <typename D>
    struct consume_Component_Edge_IZeroClassStatics
    {
        void StaticMethod() const;
    };
    template <> struct consume<Component::Edge::IZeroClassStatics>
    {
        template <typename D> using type = consume_Component_Edge_IZeroClassStatics<D>;
    };
}
#endif
