// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.000000.0
#pragma once
#include "winrt/base.h"
namespace winrt::Component::Collections
{
    struct IClass;
    struct IClassStatics;
    struct Class;
}
namespace winrt::impl
{
    template <> struct category<Component::Collections::IClass>
    {
        using type = interface_category;
    };
    template <> struct category<Component::Collections::IClassStatics>
    {
        using type = interface_category;
    };
    template <> struct category<Component::Collections::Class>
    {
        using type = class_category;
    };
    template <> struct name<Component::Collections::IClass>
    {
        static constexpr auto & value{ L"Component.Collections.IClass" };
    };
    template <> struct name<Component::Collections::IClassStatics>
    {
        static constexpr auto & value{ L"Component.Collections.IClassStatics" };
    };
    template <> struct name<Component::Collections::Class>
    {
        static constexpr auto & value{ L"Component.Collections.Class" };
    };
    template <> struct guid_storage<Component::Collections::IClass>
    {
        static constexpr guid value{ 0x0CDB4D56,0x3EA5,0x5C34,{ 0xB0,0x2C,0xE4,0xE4,0x69,0x49,0x86,0x4B } };
    };
    template <> struct guid_storage<Component::Collections::IClassStatics>
    {
        static constexpr guid value{ 0xAF59A423,0x9A7D,0x5C88,{ 0xB9,0x15,0xDD,0xD1,0x85,0x92,0xCB,0xD5 } };
    };
    template <> struct default_interface<Component::Collections::Class>
    {
        using type = Component::Collections::IClass;
    };
    template <> struct abi<Component::Collections::IClass>
    {
        struct type : inspectable_abi
        {
        };
    };
    template <> struct abi<Component::Collections::IClassStatics>
    {
        struct type : inspectable_abi
        {
            virtual int32_t WINRT_CALL Iterable(void**) noexcept = 0;
            virtual int32_t WINRT_CALL VectorView(void**) noexcept = 0;
            virtual int32_t WINRT_CALL Vector(void**) noexcept = 0;
            virtual int32_t WINRT_CALL IterablePair(void**) noexcept = 0;
            virtual int32_t WINRT_CALL MapView(void**) noexcept = 0;
            virtual int32_t WINRT_CALL Map(void**) noexcept = 0;
        };
    };
    template <typename D>
    struct consume_Component_Collections_IClass
    {
    };
    template <> struct consume<Component::Collections::IClass>
    {
        template <typename D> using type = consume_Component_Collections_IClass<D>;
    };
    template <typename D>
    struct consume_Component_Collections_IClassStatics
    {
        Windows::Foundation::Collections::IIterable<hstring> Iterable() const;
        Windows::Foundation::Collections::IVectorView<hstring> VectorView() const;
        Windows::Foundation::Collections::IVector<hstring> Vector() const;
        Windows::Foundation::Collections::IIterable<Windows::Foundation::Collections::IKeyValuePair<hstring, int32_t>> IterablePair() const;
        Windows::Foundation::Collections::IMapView<hstring, int32_t> MapView() const;
        Windows::Foundation::Collections::IMap<hstring, int32_t> Map() const;
    };
    template <> struct consume<Component::Collections::IClassStatics>
    {
        template <typename D> using type = consume_Component_Collections_IClassStatics<D>;
    };
}
