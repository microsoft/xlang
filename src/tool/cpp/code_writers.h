#pragma once

namespace xlang
{
    void write_license(writer& w)
    {
        auto format = R"(// WARNING: Please don't edit this file. It was generated by C++/WinRT v%
)";

        w.write(format, XLANG_VERSION_STRING);
    }

    void write_include_guard(writer& w)
    {
        auto format = R"(#pragma once
)";

        w.write(format);
    }

    void write_pch(writer& w)
    {
        auto format = R"(#include "%"
)";

        if (!settings.component_pch.empty())
        {
            w.write(format, settings.component_pch);
        }
    }

    void write_impl_namespace(writer& w)
    {
        auto format = R"(namespace winrt::impl
{
)";

        w.write(format);
    }

    void write_root_namespace(writer& w)
    {
        w.write(R"(namespace winrt
{
)");
    }

    void write_std_namespace(writer& w)
    {
        w.write(R"(namespace std
{
)");
    }

    void write_type_namespace(writer& w, std::string_view const& ns)
    {
        auto format = R"(namespace winrt::@
{
)";

        w.write(format, ns);
    }

    void write_close_namespace(writer& w)
    {
        auto format = R"(}
)";

        w.write(format);
    }

    void write_enum_field(writer& w, Field const& field)
    {
        auto format = R"(        % = %,
)";

        if (auto constant = field.Constant())
        {
            w.write(format, field.Name(), *constant);
        }
    }

    void write_enum(writer& w, TypeDef const& type)
    {
        auto format = R"(    enum class % : %
    {
%    };
)";

        auto fields = type.FieldList();
        w.write(format, type.TypeName(), fields.first.Signature().Type(), bind_each<write_enum_field>(fields));
    }

    void write_forward(writer& w, TypeDef const& type)
    {
        auto type_name = type.TypeName();

        if (get_category(type) == category::enum_type)
        {
            auto format = R"(    enum class % : %;
)";

            w.write(format, type_name, type.FieldList().first.Signature().Type());
        }
        else if ((type_name == "DateTime" || type_name == "TimeSpan") && type.TypeNamespace() == "Windows.Foundation")
        {
            // Don't forward declare these since they're not structs.
        }
        else
        {
            auto format = R"(    struct %;
)";

            w.write(format, type_name);
        }
    }

    void write_enum_flag(writer& w, TypeDef const& type)
    {
        auto format = R"(    template<> struct is_enum_flag<@::%> : std::true_type
    {
    };
)";

        if (has_attribute(type, "System", "FlagsAttribute"))
        {
            w.write(format, type.TypeNamespace(), type.TypeName());
        }
    }

    void write_category(writer& w, TypeDef const& type, std::string_view const& category)
    {
        auto format = R"(    template <> struct category<%>
    {
        using type = %;
    };
)";

        w.write(format, type, category);
    }

    void write_name(writer& w, TypeDef const& type)
    {
        auto format = R"(    template <> struct name<@::%>
    {
        static constexpr auto & value{ L"%.%" };
    };
)";

        auto type_namespace = type.TypeNamespace();
        auto type_name = type.TypeName();

        w.write(format, type_namespace, type_name, type_namespace, type_name);
    }

    void write_guid_value(writer& w, std::vector<FixedArgSig> const& args)
    {
        using std::get;

        w.write_printf("0x%08X,0x%04X,0x%04X,{ 0x%02X,0x%02X,0x%02X,0x%02X,0x%02X,0x%02X,0x%02X,0x%02X }",
            get<uint32_t>(get<ElemSig>(args[0].value).value),
            get<uint16_t>(get<ElemSig>(args[1].value).value),
            get<uint16_t>(get<ElemSig>(args[2].value).value),
            get<uint8_t>(get<ElemSig>(args[3].value).value),
            get<uint8_t>(get<ElemSig>(args[4].value).value),
            get<uint8_t>(get<ElemSig>(args[5].value).value),
            get<uint8_t>(get<ElemSig>(args[6].value).value),
            get<uint8_t>(get<ElemSig>(args[7].value).value),
            get<uint8_t>(get<ElemSig>(args[8].value).value),
            get<uint8_t>(get<ElemSig>(args[9].value).value),
            get<uint8_t>(get<ElemSig>(args[10].value).value));
    }

    void write_guid(writer& w, TypeDef const& type)
    {
        auto format = R"(    template <> struct guid_storage<%>
    {
        static constexpr guid value{ % };
    };
)";

        auto attribute = get_attribute(type, "Windows.Foundation.Metadata", "GuidAttribute");

        if (!attribute)
        {
            throw_invalid("'Windows.Foundation.Metadata.GuidAttribute' attribute for type '", type.TypeNamespace(), ".", type.TypeName(), "' not found");
        }

        w.write(format, type, bind<write_guid_value>(attribute.Value().FixedArgs()));
    }

    void write_fast_version(writer& w, TypeDef const& type)
    {
        if (!is_fast_class(type))
        {
            return;
        }

        auto format = R"(    template <> struct fast_version<%>
    {
        using type = %;
    };
)";

        auto interfaces = get_fast_interfaces(w, type);

        w.write(format,
            type,
            interfaces.back().name);
    }

    void write_default_interface(writer& w, TypeDef const& type)
    {
        if (auto default_interface = get_default_interface(type))
        {
            if (is_fast_class(type))
            {
        auto format = R"(    template <> struct default_interface<%>
    {
        using type = fast_interface<%>;
    };
)";
                w.write(format, type, type);
            }
            else
            {
        auto format = R"(    template <> struct default_interface<%>
    {
        using type = %;
    };
)";
                w.write(format, type, default_interface);
            }
        }
    }

    void write_struct_category(writer& w, TypeDef const& type)
    {
        auto format = R"(    template <> struct category<%>
    {
        using type = struct_category<%>;
    };
)";

        w.write(format, type, bind_list(", ", type.FieldList()));
    }

    void write_array_size_name(writer& w, Param const& param)
    {
        if (w.param_names)
        {
            w.write(" __%Size", param.Name());
        }
    }

    void write_abi_params(writer& w, method_signature const& method_signature)
    {
        w.abi_types = true;
        separator s{ w };

        for (auto&&[param, param_signature] : method_signature.params())
        {
            s();

            if (param_signature->Type().is_szarray())
            {
                std::string_view format;

                if (param.Flags().In())
                {
                    format = "uint32_t%, %*";
                }
                else if (param_signature->ByRef())
                {
                    format = "uint32_t*%, %**";
                }
                else
                {
                    format = "uint32_t%, %*";
                }

                w.write(format, bind<write_array_size_name>(param), param_signature->Type());
            }
            else
            {
                w.write(param_signature->Type());

                if (param.Flags().In())
                {
                    XLANG_ASSERT(!param.Flags().Out());

                    if (is_const(*param_signature))
                    {
                        w.write(" const&");
                    }
                }
                else
                {
                    XLANG_ASSERT(!param.Flags().In());
                    XLANG_ASSERT(param.Flags().Out());

                    w.write('*');
                }
            }

            if (w.param_names)
            {
                w.write(" %", param.Name());
            }
        }

        if (method_signature.return_signature())
        {
            s();

            auto const& type = method_signature.return_signature().Type();

            if (type.is_szarray())
            {
                w.write("uint32_t* __%Size, %**", method_signature.return_param_name(), type);
            }
            else
            {
                w.write("%*", type);
            }

            if (w.param_names)
            {
                w.write(" %", method_signature.return_param_name());
            }
        }
    }

    bool can_take_ownership_of_return_type(method_signature const& signature)
    {
        TypeSig const& return_signature = signature.return_signature().Type();

        if (auto type_def = std::get_if<coded_index<TypeDefOrRef>>(&return_signature.Type()))
        {
            auto category = category::interface_type;

            if (type_def->type() == TypeDefOrRef::TypeRef)
            {
                auto type_ref = type_def->TypeRef();

                if (type_ref.TypeName() == "Guid" && type_ref.TypeNamespace() == "System")
                {
                    return false;
                }

                category = get_category(find_required(type_ref));
            }
            else if (type_def->type() == TypeDefOrRef::TypeDef)
            {
                category = get_category(type_def->TypeDef());
            }

            return category == category::class_type || category == category::interface_type || category == category::delegate_type;
        }
        else if (auto element_type = std::get_if<ElementType>(&return_signature.Type()))
        {
            return *element_type == ElementType::String;
        }

        return false;
    }

    void write_abi_args(writer& w, method_signature const& method_signature)
    {
        separator s{ w };

        for (auto&&[param, param_signature] : method_signature.params())
        {
            s();
            auto param_name = param.Name();

            if (param_signature->Type().is_szarray())
            {
                std::string_view format;

                if (param.Flags().In())
                {
                    format = "%.size(), get_abi(%)";
                }
                else if (param_signature->ByRef())
                {
                    format = "impl::put_size_abi(%), put_abi(%)";
                }
                else
                {
                    format = "%.size(), get_abi(%)";
                }

                w.write(format, param_name, param_name);
            }
            else
            {
                if (param.Flags().In())
                {
                    XLANG_ASSERT(!param.Flags().Out());

                    if (wrap_abi(param_signature->Type()))
                    {
                        w.write("get_abi(%)", param_name);
                    }
                    else
                    {
                        w.write(param_name);
                    }
                }
                else
                {
                    XLANG_ASSERT(!param.Flags().In());
                    XLANG_ASSERT(param.Flags().Out());

                    if (wrap_abi(param_signature->Type()))
                    {
                        w.write("put_abi(%)", param_name);
                    }
                    else
                    {
                        w.write("&%", param_name);
                    }
                }
            }
        }

        if (method_signature.return_signature())
        {
            s();
            auto const& type = method_signature.return_signature().Type();
            auto param_name = method_signature.return_param_name();

            if (type.is_szarray())
            {
                w.write("impl::put_size_abi(%), put_abi(%)", param_name, param_name);
            }
            else
            {
                if (!can_take_ownership_of_return_type(method_signature) && wrap_abi(method_signature.return_signature().Type()))
                {
                    w.write("put_abi(%)", param_name);
                }
                else
                {
                    w.write("&%", param_name);
                }
            }
        }
    }

    void write_abi_declaration(writer& w, MethodDef const& method)
    {
        auto format = R"(        virtual int32_t WINRT_CALL %(%) noexcept = 0;
)";

        w.param_names = false;
        method_signature signature{ method };
        w.write(format, get_abi_name(method), bind<write_abi_params>(signature));
    }

    void write_fast_abi(writer& w, TypeDef const& type)
    {
        if (!is_fast_class(type))
        {
            return;
        }

        auto format = R"(    template <> struct abi<fast_interface<@::%>>
    {
        struct type : inspectable_abi
        {
)";

        w.write(format, type.TypeNamespace(), type.TypeName());

        for (auto&& info : get_fast_interfaces(w, type))
        {
            for (auto&& method : info.methods)
            {
                format = R"(            virtual int32_t WINRT_CALL %(%) noexcept = 0;
)";

                w.param_names = false;
                method_signature signature{ method };

                w.write(format,
                    get_abi_name(method),
                    bind<write_abi_params>(signature));
            }
        }

        w.write(R"(        };
    };
)");
    }

    void write_interface_abi(writer& w, TypeDef const& type)
    {
        auto guard{ w.push_generic_params(type.GenericParam()) };

        auto format = R"(    template <> struct abi<@::%>
    {
        struct type : inspectable_abi
        {
)";

        w.write(format, type.TypeNamespace(), type.TypeName());

        format = R"(            virtual int32_t WINRT_CALL %(%) noexcept = 0;
)";

        for (auto&& method : type.MethodList())
        {
            method_signature signature{ method };
            w.write(format, get_abi_name(method), bind<write_abi_params>(signature));
        }

        w.write(R"(        };
    };
)");
    }

    void write_delegate_abi(writer& w, TypeDef const& type)
    {
        auto format = R"(    template <> struct abi<@::%>
    {
        struct type : unknown_abi
        {
            virtual int32_t WINRT_CALL Invoke(%) noexcept = 0;
        };
    };
)";

        auto guard{ w.push_generic_params(type.GenericParam()) };
        auto method = get_delegate_method(type);
        method_signature signature{ method };

        w.write(format,
            type.TypeNamespace(),
            type.TypeName(),
            bind<write_abi_params>(signature));
    }

    void write_field_abi(writer& w, Field const& field)
    {
        w.write("        % %;\n", get_field_abi(w, field), field.Name());
    }

    void write_struct_abi(writer& w, TypeDef const& type)
    {
        w.abi_types = true;

        auto format = R"(    struct struct_%
    {
%    };
    template <> struct abi<@::%>
    {
        using type = struct_%;
    };
)";

        auto type_name = type.TypeName();
        auto type_namespace = type.TypeNamespace();
        auto impl_name = get_impl_name(type_namespace, type_name);

        w.write(format,
            impl_name,
            bind_each<write_field_abi>(type.FieldList()),
            type_namespace,
            type_name,
            impl_name);

    }

    void write_consume_params(writer& w, method_signature const& signature)
    {
        separator s{ w };

        for (auto&&[param, param_signature] : signature.params())
        {
            s();

            if (param_signature->Type().is_szarray())
            {
                std::string_view format;

                if (param.Flags().In())
                {
                    format = "array_view<% const>";
                }
                else if (param_signature->ByRef())
                {
                    format = "com_array<%>&";
                }
                else
                {
                    format = "array_view<%>";
                }

                w.write(format, param_signature->Type().Type());
            }
            else
            {
                if (param.Flags().In())
                {
                    XLANG_ASSERT(!param.Flags().Out());
                    w.consume_types = true;

                    auto param_type = std::get_if<ElementType>(&param_signature->Type().Type());

                    if (param_type && *param_type != ElementType::String && *param_type != ElementType::Object)
                    {
                        w.write("%", param_signature->Type());
                    }
                    else
                    {
                        w.write("% const&", param_signature->Type());
                    }

                    w.consume_types = false;
                }
                else
                {
                    XLANG_ASSERT(!param.Flags().In());
                    XLANG_ASSERT(param.Flags().Out());

                    w.write("%&", param_signature->Type());
                }
            }

            w.write(" %", param.Name());
        }
    }

    void write_implementation_params(writer& w, method_signature const& method_signature)
    {
        separator s{ w };

        for (auto&&[param, param_signature] : method_signature.params())
        {
            s();

            if (param_signature->Type().is_szarray())
            {
                std::string_view format;

                if (param.Flags().In())
                {
                    format = "array_view<% const>";
                }
                else if (param_signature->ByRef())
                {
                    format = "com_array<%>&";
                }
                else
                {
                    format = "array_view<%>";
                }

                w.write(format, param_signature->Type().Type());
            }
            else
            {
                if (param.Flags().In())
                {
                    XLANG_ASSERT(!param.Flags().Out());

                    auto param_type = std::get_if<ElementType>(&param_signature->Type().Type());

                    if (w.async_types || (param_type && *param_type != ElementType::String && *param_type != ElementType::Object))
                    {
                        w.write("%", param_signature->Type());
                    }
                    else
                    {
                        w.write("% const&", param_signature->Type());
                    }
                }
                else
                {
                    XLANG_ASSERT(!param.Flags().In());
                    XLANG_ASSERT(param.Flags().Out());

                    w.write("%&", param_signature->Type());
                }
            }

            if (w.param_names)
            {
                w.write(" %", param.Name());
            }
        }
    }

    void write_consume_declaration(writer& w, MethodDef const& method)
    {
        method_signature signature{ method };
        w.async_types = is_async(method, signature);
        auto method_name = get_name(method);
        auto type = method.Parent();

        w.write("        % %(%) const%;\n",
            signature.return_signature(),
            method_name,
            bind<write_consume_params>(signature),
            is_noexcept(method) ? " noexcept" : "");

        if (is_add_overload(method))
        {
            auto format = R"(        using %_revoker = impl::event_revoker<%, &impl::abi_t<%>::remove_%>;
        %_revoker %(auto_revoke_t, %) const;
)";

            w.write(format,
                method_name,
                type,
                type,
                method_name,
                method_name,
                method_name,
                bind<write_consume_params>(signature));
        }
    }

    void write_consume_return_type(writer& w, method_signature const& signature)
    {
        if (!signature.return_signature())
        {
            return;
        }

        if (can_take_ownership_of_return_type(signature))
        {
            auto format = "\n        void* %;";
            w.write(format, signature.return_param_name());
        }
        else
        {
            auto format = "\n        % %;";
            w.write(format, signature.return_signature(), signature.return_param_name());
        }
    }

    void write_consume_return_statement(writer& w, method_signature const& signature)
    {
        if (!signature.return_signature())
        {
            return;
        }

        if (can_take_ownership_of_return_type(signature))
        {
            w.write("\n        return { take_ownership_from_abi, % };", signature.return_param_name());
        }
        else
        {
            w.write("\n        return %;", signature.return_param_name());
        }
    }

    void write_consume_args(writer& w, method_signature const& signature)
    {
        separator s{ w };

        for (auto&&[param, param_signature] : signature.params())
        {
            s();
            w.write(param.Name());
        }
    }

    void write_consume_definitions(writer& w, TypeDef const& type)
    {
        auto guard{ w.push_generic_params(type.GenericParam()) };
        auto type_name = type.TypeName();
        auto type_namespace = type.TypeNamespace();
        auto type_impl_name = get_impl_name(type_namespace, type_name);

        for (auto&& method : type.MethodList())
        {
            auto method_name = get_name(method);
            method_signature signature{ method };
            w.async_types = is_async(method, signature);

            std::string_view format;

            if (is_noexcept(method))
            {
                format = R"(    template <typename D> % consume_%<D>::%(%) const noexcept
    {%
        WINRT_VERIFY_(0, WINRT_SHIM(@::%)->%(%));%
    }
)";
            }
            else
            {
                format = R"(    template <typename D> % consume_%<D>::%(%) const
    {%
        check_hresult(WINRT_SHIM(@::%)->%(%));%
    }
)";
            }

            w.write(format,
                signature.return_signature(),
                type_impl_name,
                method_name,
                bind<write_consume_params>(signature),
                bind<write_consume_return_type>(signature),
                type_namespace,
                type_name,
                get_abi_name(method),
                bind<write_abi_args>(signature),
                bind<write_consume_return_statement>(signature));

            if (is_add_overload(method))
            {
                format = R"(    template <typename D> typename consume_%<D>::%_revoker consume_%<D>::%(auto_revoke_t, %) const
    {
        return impl::make_event_revoker<D, %_revoker>(this, %(%));
    }
)";

                w.write(format,
                    type_impl_name,
                    method_name,
                    type_impl_name,
                    method_name,
                    bind<write_consume_params>(signature),
                    method_name,
                    method_name,
                    bind<write_consume_args>(signature));
            }
        }
    }

    void write_fast_definitions(writer& w, TypeDef const& type)
    {
        if (!is_fast_class(type))
        {
            return;
        }

        auto type_name = type.TypeName();

        for (auto&& info : get_fast_interfaces(w, type))
        {
            for (auto&& method : info.methods)
            {
                auto method_name = get_name(method);
                method_signature signature{ method };
                w.async_types = is_async(method, signature);

                std::string_view format;

                if (is_noexcept(method))
                {
                    format = R"(    inline % %::%(%) const noexcept
    {%
        WINRT_VERIFY_(0, (*(impl::abi_t<fast_interface<%>>**)this)->%(%));%
    }
)";
                }
                else
                {
                    format = R"(    inline % %::%(%) const
    {%
        check_hresult((*(impl::abi_t<fast_interface<%>>**)this)->%(%));%
    }
)";
                }

                w.write(format,
                    signature.return_signature(),
                    type_name,
                    method_name,
                    bind<write_consume_params>(signature),
                    bind<write_consume_return_type>(signature),
                    type_name,
                    get_abi_name(method),
                    bind<write_abi_args>(signature),
                    bind<write_consume_return_statement>(signature));

                if (is_add_overload(method))
                {
                    format = R"(    inline %::%_revoker %::%(auto_revoke_t, %) const
    {
        return impl::make_event_revoker<%, %_revoker>(this, %(%));
    }
)";

                    w.write(format,
                        type_name,
                        method_name,
                        type_name,
                        method_name,
                        bind<write_consume_params>(signature),
                        method_name,
                        method_name,
                        bind<write_consume_args>(signature));
                }
            }
        }
    }

    void write_consume(writer& w, TypeDef const& type)
    {
        auto format = R"(    template <typename D>
    struct consume_%
    {
%%    };
    template <> struct consume<@::%>
    {
        template <typename D> using type = consume_%<D>;
    };
)";

        w.abi_types = false;
        auto guard{ w.push_generic_params(type.GenericParam()) };
        auto type_name = type.TypeName();
        auto type_namespace = type.TypeNamespace();
        auto impl_name = get_impl_name(type_namespace, type_name);

        w.write(format,
            impl_name,
            bind_each<write_consume_declaration>(type.MethodList()),
            "",
            type_namespace,
            type_name,
            impl_name);
    }

    void write_produce_params(writer& w, method_signature const& signature)
    {
        w.param_names = true;
        write_abi_params(w, signature);
    }

    void write_produce_cleanup_param(writer& w, TypeSig const& signature, std::string_view const& param_name, bool out)
    {
        if (signature.is_szarray())
        {
            auto format = R"(                *__%Size = 0;
                *% = nullptr;
)";

            w.write(format,
                param_name,
                param_name);

            return;
        }

        bool clear{};
        bool optional{};

        xlang::visit(signature.Type(),
            [&](ElementType type)
        {
            if (out && type == ElementType::Object)
            {
                optional = true;
            }
            else if (type == ElementType::String || type == ElementType::Object)
            {
                clear = true;
            }
        },
            [&](coded_index<TypeDefOrRef> const& index)
        {
            XLANG_ASSERT(index.type() == TypeDefOrRef::TypeDef || index.type() == TypeDefOrRef::TypeRef);

            TypeDef type;

            if (index.type() == TypeDefOrRef::TypeDef)
            {
                type = index.TypeDef();
            }
            else if (index.type() == TypeDefOrRef::TypeRef)
            {
                type = find(index.TypeRef());
            }

            if (type)
            {
                auto category = get_category(type);

                clear = category == category::class_type || category == category::interface_type || category == category::delegate_type;
            }
        },
            [&](GenericTypeInstSig const&)
        {
            clear = true;
        },
            [](auto&&) {});

        if (optional)
        {
            auto format = R"(                if (%) *% = nullptr;
                Windows::Foundation::IInspectable winrt_impl_%;
)";

            w.write(format, param_name, param_name, param_name);
        }
        else if (clear)
        {
            auto format = R"(                *% = nullptr;
)";

            w.write(format, param_name);
        }
    }

    void write_produce_cleanup(writer& w, method_signature const& method_signature)
    {
        for (auto&&[param, param_signature] : method_signature.params())
        {
            if (param.Flags().In() || !param_signature->ByRef())
            {
                continue;
            }

            write_produce_cleanup_param(w, param_signature->Type(), param.Name(), true);
        }

        if (method_signature.return_signature())
        {
            write_produce_cleanup_param(w, method_signature.return_signature().Type(), method_signature.return_param_name(), false);
        }
    }

    void write_produce_args(writer& w, method_signature const& method_signature)
    {
        w.abi_types = false;
        separator s{ w };

        for (auto&&[param, param_signature] : method_signature.params())
        {
            s();
            auto param_name = param.Name();
            auto param_type = w.write_temp("%", param_signature->Type().Type());

            if (param_signature->Type().is_szarray())
            {
                if (param.Flags().In())
                {
                    w.write("array_view<@ const>(reinterpret_cast<@ const *>(%), reinterpret_cast<@ const *>(%) + __%Size)",
                        param_type,
                        param_type,
                        param_name,
                        param_type,
                        param_name,
                        param_name);
                }
                else if (param_signature->ByRef())
                {
                    w.write("detach_abi<@>(__%Size, %)",
                        param_type,
                        param_name,
                        param_name);
                }
                else
                {
                    w.write("array_view<@>(reinterpret_cast<@*>(%), reinterpret_cast<@*>(%) + __%Size)",
                        param_type,
                        param_type,
                        param_name,
                        param_type,
                        param_name,
                        param_name);
                }
            }
            else
            {
                if (param.Flags().In())
                {
                    if (wrap_abi(param_signature->Type()))
                    {
                        w.write("*reinterpret_cast<% const*>(&%)",
                            param_type,
                            param_name);
                    }
                    else
                    {
                        w.write(param_name);
                    }
                }
                else
                {
                    if (is_object(param_signature->Type()))
                    {
                        w.write("winrt_impl_%", param_name);
                    }
                    else if (wrap_abi(param_signature->Type()))
                    {
                        w.write("*reinterpret_cast<@*>(%)",
                            param_type,
                            param_name);
                    }
                    else
                    {
                        w.write("*%", param_name);
                    }
                }
            }
        }
    }

    void write_produce_upcall(writer& w, MethodDef const& method, method_signature const& method_signature)
    {
        w.abi_types = false;

        if (method_signature.return_signature())
        {
            auto name = method_signature.return_param_name();

            if (method_signature.return_signature().Type().is_szarray())
            {
                w.write("std::tie(*__%Size, *%) = detach_abi(this->shim().%(%));",
                    name,
                    name,
                    get_name(method),
                    bind<write_produce_args>(method_signature));
            }
            else
            {
                w.write("*% = detach_from<%>(this->shim().%(%));",
                    name,
                    method_signature.return_signature(),
                    get_name(method),
                    bind<write_produce_args>(method_signature));
            }
        }
        else
        {
            w.write("this->shim().%(%);",
                get_name(method),
                bind<write_produce_args>(method_signature));
        }

        for (auto&&[param, param_signature] : method_signature.params())
        {
            if (param.Flags().Out() && !param_signature->Type().is_szarray() && is_object(param_signature->Type()))
            {
                auto param_name = param.Name();

                w.write("\n            if (%) *% = detach_abi(winrt_impl_%);", param_name, param_name, param_name);
            }
        }
    }

    void write_delegate_upcall(writer& w, method_signature const& method_signature)
    {
        w.abi_types = false;

        if (method_signature.return_signature())
        {
            auto name = method_signature.return_param_name();

            if (method_signature.return_signature().Type().is_szarray())
            {
                w.write("std::tie(*__%Size, *%) = detach_abi((*this)(%))",
                    name,
                    name,
                    bind<write_produce_args>(method_signature));
            }
            else
            {
                w.write("*% = detach_from<%>((*this)(%))",
                    name,
                    method_signature.return_signature(),
                    bind<write_produce_args>(method_signature));
            }
        }
        else
        {
            w.write("(*this)(%)",
                bind<write_produce_args>(method_signature));
        }
    }

    void write_produce_method(writer& w, MethodDef const& method)
    {
        std::string_view format;

        if (is_noexcept(method))
        {
            format = R"(        int32_t WINRT_CALL %(%) noexcept final
        {
%            typename D::abi_guard guard(this->shim());
            %
            return 0;
        }
)";
        }
        else
        {
            format = R"(        int32_t WINRT_CALL %(%) noexcept final
        {
            try
            {
%                typename D::abi_guard guard(this->shim());
                %
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
)";
        }

        method_signature signature{ method };
        w.async_types = is_async(method, signature);

        w.write(format,
            get_abi_name(method),
            bind<write_produce_params>(signature),
            bind<write_produce_cleanup>(signature),
            bind<write_produce_upcall>(method, signature));
    }

    void write_fast_produce_methods(writer& w, TypeDef const& type)
    {
        for (auto&& info : get_fast_interfaces(w, type))
        {
            for (auto&& method : info.methods)
            {
                write_produce_method(w, method);
            }
        }
    }

    void write_produce(writer& w, TypeDef const& type)
    {
        auto format = R"(    template <typename D>
    struct produce<D, %> : produce_base<D, %>
    {
%    };
)";

        auto guard{ w.push_generic_params(type.GenericParam()) };

        w.write(format,
            type,
            type,
            bind_each<write_produce_method>(type.MethodList()));
    }

    void write_fast_produce(writer& w, TypeDef const& type)
    {
        if (!is_fast_class(type))
        {
            return;
        }

        auto format = R"(    template <typename D>
    struct produce<D, fast_interface<%>> : produce_base<D, fast_interface<%>>
    {
%    };
)";

        auto guard{ w.push_generic_params(type.GenericParam()) };

        w.write(format,
            type,
            type,
            bind<write_fast_produce_methods>(type));
    }

    void write_dispatch_overridable_method(writer& w, MethodDef const& method)
    {
        auto format = R"(    % %(%)
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.%(%);
        }

        return this->shim().%(%);
    }
)";

        method_signature signature{ method };

        w.write(format,
            signature.return_signature(),
            get_name(method),
            bind<write_implementation_params>(signature),
            get_name(method),
            bind<write_consume_args>(signature),
            get_name(method),
            bind<write_consume_args>(signature));
    }

    void write_dispatch_overridable(writer& w, TypeDef const& class_type)
    {
        auto format = R"(template <typename T, typename D>
struct WINRT_EBO produce_dispatch_to_overridable<T, D, %>
    : produce_dispatch_to_overridable_base<T, D, %>
{
%};)";

        for (auto&&[interface_name, info] : get_interfaces(w, class_type))
        {
            if (info.overridable && !info.base)
            {
                w.write(format,
                    interface_name,
                    interface_name,
                    bind_each<write_dispatch_overridable_method>(info.methods));
            }
        }
    }

    void write_interface_override_method(writer& w, MethodDef const& method, std::string_view const& interface_name)
    {
        auto format = R"(template <typename D> % %T<D>::%(%) const
{
    return shim().template try_as<%>().%(%);
}
)";

        method_signature signature{ method };
        auto method_name = get_name(method);

        w.write(format,
            signature.return_signature(),
            interface_name,
            method_name,
            bind<write_consume_params>(signature),
            interface_name,
            method_name,
            bind<write_consume_args>(signature));
    }

    void write_interface_override_methods(writer& w, TypeDef const& class_type)
    {
        for (auto&&[interface_name, info] : get_interfaces(w, class_type))
        {
            if (info.overridable && !info.base)
            {
                auto name = info.type.TypeRef().TypeName();

                w.write_each<write_interface_override_method>(info.methods, name);
            }
        };
    }

    void write_class_override_implements(writer& w, std::map<std::string, interface_info> const& interfaces)
    {
        bool found{};

        for (auto&&[name, info] : interfaces)
        {
            if (info.overridable)
            {
                w.write(", %", name);
                found = true;
            }
        }

        if (!found)
        {
            w.write(", Windows::Foundation::IInspectable");
        }
    }

    void write_class_override_requires(writer& w, std::map<std::string, interface_info> const& interfaces)
    {
        bool found{};

        for (auto&&[name, info] : interfaces)
        {
            if (!info.overridable)
            {
                w.write(", %", name);
                found = true;
            }
        }
    }

    void write_class_override_defaults(writer& w, std::map<std::string, interface_info> const& interfaces)
    {
        bool first{ true };

        for (auto&&[name, info] : interfaces)
        {
            if (!info.overridable)
            {
                continue;
            }

            if (first)
            {
                first = false;
                w.write(",\n    %T<D>", name);
            }
            else
            {
                w.write(", %T<D>", name);
            }
        }
    }

    void write_class_override_bases(writer& w, TypeDef const& type)
    {
        for (auto&& base : get_bases(type))
        {
            w.write(", %", base);
        }
    }

    void write_class_override_constructors(writer& w, std::string_view const& type_name, std::vector<factory_type> const& factories)
    {
        auto format = R"(    %T(%)
    {
        impl::call_factory<%, %>([&](auto&& f) { f.%(%%*this, this->m_inner); });
    }
)";

        for (auto&& factory : factories)
        {
            if (!factory.composable)
            {
                continue;
            }

            for (auto&& method : factory.type.MethodList())
            {
                method_signature signature{ method };
                auto& params = signature.params();
                params.resize(params.size() - 2);

                w.write(format,
                    type_name,
                    bind<write_consume_params>(signature),
                    type_name,
                    factory.type,
                    get_name(method),
                    bind<write_consume_args>(signature),
                    signature.params().empty() ? "" : ", ");
            }
        }
    }

    void write_interface_override(writer& w, TypeDef const& type)
    {
        auto format = R"(template <typename D>
class %T
{
    D& shim() noexcept { return *static_cast<D*>(this); }
    D const& shim() const noexcept { return *static_cast<const D*>(this); }

public:

    using % = winrt::@::%;

%};
)";

        for (auto&&[interface_name, info] : get_interfaces(w, type))
        {
            if (info.overridable && !info.base)
            {
                auto interface_type = find(info.type.TypeRef());
                auto interface_type_name = interface_type.TypeName();

                w.write(format,
                    interface_type_name,
                    interface_type_name,
                    interface_type.TypeNamespace(),
                    interface_type_name,
                    bind_each<write_consume_declaration>(interface_type.MethodList()));
            }
        }
    }

    void write_class_override(writer& w, TypeDef const& type)
    {
        auto factories = get_factories(type);
        bool has_composable_factories{};

        for (auto&& factory : factories)
        {
            if (factory.composable && !empty(factory.type.MethodList()))
            {
                has_composable_factories = true;
                break;
            }
        }

        if (!has_composable_factories)
        {
            return;
        }

        auto format = R"(template <typename D, typename... Interfaces>
struct %T :
    implements<D%, composing, Interfaces...>,
    impl::require<D%>,
    impl::base<D, %%>%
{
    using composable = %;

protected:
%};
)";

        auto type_name = type.TypeName();
        auto interfaces = get_interfaces(w, type);

        w.write(format,
            type_name,
            bind<write_class_override_implements>(interfaces),
            bind<write_class_override_requires>(interfaces),
            type_name,
            bind<write_class_override_bases>(type),
            bind<write_class_override_defaults>(interfaces),
            type_name,
            bind<write_class_override_constructors>(type_name, factories));
    }

    void write_interface_requires(writer& w, TypeDef const& type)
    {
        auto interfaces = get_interfaces(w, type);

        if (interfaces.empty())
        {
            return;
        }

        w.write(",\n    impl::require<%", type.TypeName());

        for (auto&&[name, info] : interfaces)
        {
            w.write(", %", name);
        }

        w.write('>');
    }

    void write_interface_usings(writer& w, TypeDef const& type)
    {
        auto type_name = type.TypeName();
        auto interfaces_plus_self = get_interfaces(w, type);
        interfaces_plus_self[std::string{ type_name }] = interface_info{ type.coded_index<TypeDefOrRef>(), type.MethodList() };
        std::map<std::string_view, std::set<std::string>> method_usage;

        for (auto&&[interface_name, info] : interfaces_plus_self)
        {
            for (auto&& method : info.methods)
            {
                method_usage[get_name(method)].insert(interface_name);
            }
        }

        for (auto&&[method_name, interfaces] : method_usage)
        {
            if (interfaces.size() <= 1)
            {
                continue;
            }

            for (auto&& interface_name : interfaces)
            {
                w.write("    using impl::consume_t<%, %>::%;\n",
                    type_name,
                    interface_name,
                    method_name);
            }
        }
    }

    void write_class_usings(writer& w, TypeDef const& type)
    {
        auto type_name = type.TypeName();
        auto default_interface = get_default_interface(type);
        auto default_interface_name = w.write_temp("%", default_interface);
        std::map<std::string_view, std::set<std::string>> method_usage;

        for (auto&&[interface_name, info] : get_interfaces(w, type))
        {
            if (info.defaulted && !info.base)
            {
                for (auto&& method : info.methods)
                {
                    method_usage[get_name(method)].insert(default_interface_name);
                }
            }
            else
            {
                for (auto&& method : info.methods)
                {
                    method_usage[get_name(method)].insert(interface_name);
                }
            }
        }

        for (auto&&[method_name, interfaces] : method_usage)
        {
            if (interfaces.size() <= 1)
            {
                continue;
            }

            for (auto&& interface_name : interfaces)
            {
                if (default_interface_name == interface_name)
                {
                    w.write("    using %::%;\n",
                        interface_name,
                        method_name);
                }
                else
                {
                    w.write("    using impl::consume_t<%, %>::%;\n",
                        type_name,
                        interface_name,
                        method_name);
                }
            }
        }

    }

    void write_interface(writer& w, TypeDef const& type)
    {
        auto format = R"(    struct WINRT_EBO % :
        Windows::Foundation::IInspectable,
        impl::consume_t<%>%
    {
        %(std::nullptr_t = nullptr) noexcept {}
        %(take_ownership_from_abi_t, void* ptr) noexcept : Windows::Foundation::IInspectable(take_ownership_from_abi, ptr) {}
    %};
)";

        auto type_name = type.TypeName();

        auto guard{ w.push_generic_params(type.GenericParam()) };

        w.write(format,
            type_name,
            type_name,
            bind<write_interface_requires>(type),
            type_name,
            type_name,
            bind<write_interface_usings>(type));
    }

    void write_delegate(writer& w, TypeDef const& type)
    {
        auto format = R"(    struct % : Windows::Foundation::IUnknown
    {
        %(std::nullptr_t = nullptr) noexcept {}
        template <typename L> %(L lambda);
        template <typename F> %(F* function);
        template <typename O, typename M> %(O* object, M method);
        template <typename O, typename M> %(com_ptr<O>&& object, M method);
        template <typename O, typename M> %(weak_ref<O>&& object, M method);
        % operator()(%) const;
    };
)";

        auto type_name = type.TypeName();
        auto guard{ w.push_generic_params(type.GenericParam()) };
        method_signature signature{ get_delegate_method(type) };

        w.write(format,
            type_name,
            type_name,
            type_name,
            type_name,
            type_name,
            type_name,
            type_name,
            signature.return_signature(),
            bind<write_consume_params>(signature));
    }

    void write_delegate_implementation(writer& w, TypeDef const& type)
    {
        auto format = R"(    template <> struct delegate<@::%>
    {
        template <typename H>
        struct type : implements_delegate<@::%, H>
        {
            type(H&& handler) : implements_delegate<@::%, H>(std::forward<H>(handler)) {}

            int32_t WINRT_CALL Invoke(%) noexcept final
            {
                try
                {
                    %;
                    return 0;
                }
                catch (...)
                {%
                    return to_hresult();
                }
            }
        };
    };
)";

        w.param_names = true;
        auto guard{ w.push_generic_params(type.GenericParam()) };
        auto type_name = type.TypeName();
        auto type_namespace = type.TypeNamespace();
        method_signature signature{ get_delegate_method(type) };

        w.write(format,
            type_namespace, type_name,
            type_namespace, type_name,
            type_namespace, type_name,
            bind<write_abi_params>(signature),
            bind<write_delegate_upcall>(signature),
            "");
    }

    void write_delegate_definition(writer& w, TypeDef const& type)
    {
        auto format = R"(    template <typename L> %::%(L handler) :
        %(impl::make_delegate<%>(std::forward<L>(handler)))
    {}

    template <typename F> %::%(F* handler) :
        %([=](auto&&... args) { return handler(args...); })
    {}

    template <typename O, typename M> %::%(O* object, M method) :
        %([=](auto&&... args) { return ((*object).*(method))(args...); })
    {}

    template <typename O, typename M> %::%(com_ptr<O>&& object, M method) :
        %([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {}

    template <typename O, typename M> %::%(weak_ref<O>&& object, M method) :
        %([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {}

    % %::operator()(%) const
    {%
        check_hresult((*(impl::abi_t<%>**)this)->Invoke(%));%
    }
)";

        auto type_name = type.TypeName();
        auto guard{ w.push_generic_params(type.GenericParam()) };
        method_signature signature{ get_delegate_method(type) };

        w.write(format,
            type_name,
            type_name,
            type_name,
            type_name,
            type_name,
            type_name,
            type_name,
            type_name,
            type_name,
            type_name,
            type_name,
            type_name,
            type_name,
            type_name,
            type_name,
            type_name,
            signature.return_signature(),
            type_name,
            bind<write_consume_params>(signature),
            bind<write_consume_return_type>(signature),
            type_name,
            bind<write_abi_args>(signature),
            bind<write_consume_return_statement>(signature));
    }

    void write_struct_field(writer& w, std::pair<std::string_view, std::string> const& field)
    {
        w.write("        @ %;\n",
            field.second,
            field.first);
    }

    void write_struct_equality(writer& w, std::vector<std::pair<std::string_view, std::string>> const& fields)
    {
        for (size_t i = 0; i != fields.size(); ++i)
        {
            w.write(" left.% == right.%", fields[i].first, fields[i].first);

            if (i + 1 != fields.size())
            {
                w.write(" &&");
            }
        }
    }

    void write_structs(writer& w, std::vector<TypeDef> const& types)
    {
        auto format = R"(    struct %
    {
%    };
    inline bool operator==(% const& left, % const& right)%
    {
        return%;
    }
    inline bool operator!=(% const& left, % const& right)%
    {
        return !(left == right);
    }
)";

        if (types.empty())
        {
            return;
        }

        struct complex_struct
        {
            complex_struct(writer& w, TypeDef const& type) :
                type(type),
                is_noexcept(!has_reference(type))
            {
                for (auto&& field : type.FieldList())
                {
                    fields.emplace_back(field.Name(), w.write_temp("%", field.Signature().Type()));
                }
            }

            static bool has_reference(TypeDef const&)
            {
                return false;
            };

            TypeDef type;
            std::vector<std::pair<std::string_view, std::string>> fields;
            bool is_noexcept{ false };
        };

        std::vector<complex_struct> structs;

        for (auto&& type : types)
        {
            structs.emplace_back(w, type);
        }

        auto depends = [](writer& w, complex_struct const& left, complex_struct const& right)
        {
            for (auto&& field : left.fields)
            {
                if (w.write_temp("@::%", right.type.TypeNamespace(), right.type.TypeName()) == field.second)
                {
                    return true;
                }
            }

            return false;
        };

        for (size_t left = 0; left < structs.size(); ++left)
        {
            for (size_t right = left + 1; right < structs.size(); ++right)
            {
                if (depends(w, structs[left], structs[right]))
                {
                    // Left depends on right, therefore move right in front of left.
                    complex_struct temp = std::move(structs[right]);
                    structs.erase(structs.begin() + right);
                    structs.insert(structs.begin() + left, std::move(temp));

                    // Start over from the newly inserted struct.
                    right = structs.size();
                    --left;
                }
            }
        }

        for (auto&& type : structs)
        {
            auto name = type.type.TypeName();
            std::string_view is_noexcept = type.is_noexcept ? " noexcept" : "";

            w.write(format,
                name,
                bind_each<write_struct_field>(type.fields),
                name,
                name,
                is_noexcept,
                bind<write_struct_equality>(type.fields),
                name,
                name,
                is_noexcept);
        }
    }

    void write_slow_class_requires(writer& w, TypeDef const& type)
    {
        bool first{ true };

        for (auto&&[interface_name, info] : get_interfaces(w, type))
        {
            if (!info.defaulted || info.base)
            {
                if (first)
                {
                    first = false;
                    w.write(",\n        impl::require<%", type.TypeName());
                }

                w.write(", %", interface_name);
            }
        }

        if (!first)
        {
            w.write('>');
        }
    }

    void write_fast_class_requires(writer& w, TypeDef const& type)
    {
        bool first{ true };

        for (auto&&[interface_name, info] : get_interfaces(w, type))
        {
            if (!info.exclusive && !info.base)
            {
                if (first)
                {
                    first = false;
                    w.write(",\n        impl::require<%", type.TypeName());
                }

                w.write(", %", interface_name);
            }
        }

        if (!first)
        {
            w.write('>');
        }
    }

    void write_class_base(writer& w, TypeDef const& type)
    {
        bool first{ true };

        for (auto&& base : get_bases(type))
        {
            if (first)
            {
                first = false;
                w.write(",\n    impl::base<%", type.TypeName());
            }

            w.write(", %", base);
        }

        if (!first)
        {
            w.write('>');
        }
    }

    void write_constructor_declarations(writer& w, TypeDef const& type, std::vector<factory_type> const& factories)
    {
        auto type_name = type.TypeName();

        for (auto&& factory : factories)
        {
            if (factory.activatable)
            {
                if (!factory.type)
                {
                    w.write("        %();\n", type_name);
                }
                else
                {
                    for (auto&& method : factory.type.MethodList())
                    {
                        method_signature signature{ method };

                        w.write("        %(%);\n",
                            type_name,
                            bind<write_consume_params>(signature));
                    }
                }
            }
            else if (factory.composable && factory.visible)
            {
                for (auto&& method : factory.type.MethodList())
                {
                    method_signature signature{ method };
                    auto& params = signature.params();
                    params.resize(params.size() - 2);

                    w.write("        %(%);\n",
                        type_name,
                        bind<write_consume_params>(signature));
                }
            }
        }
    }

    void write_constructor_definition(writer& w, MethodDef const& method, std::string_view const& type_name, TypeDef const& factory)
    {
        method_signature signature{ method };

        auto format = R"(    inline %::%(%) :
        %(impl::call_factory<%, @::%>([&](auto&& f) { return f.%(%); }))
    {
    }
)";

        w.write(format,
            type_name,
            type_name,
            bind<write_consume_params>(signature),
            type_name,
            type_name,
            factory.TypeNamespace(), factory.TypeName(),
            get_name(method),
            bind<write_consume_args>(signature));
    }

    void write_composable_constructor_definition(writer& w, MethodDef const& method, std::string_view const& type_name, TypeDef const& factory)
    {
        method_signature signature{ method };
        auto& params = signature.params();
        auto inner_param = params.back().first.Name();
        params.pop_back();
        auto base_param = params.back().first.Name();
        params.pop_back();

        auto format = R"(    inline %::%(%)
    {
        Windows::Foundation::IInspectable %, %;
        *this = impl::call_factory<%, @::%>([&](auto&& f) { return f.%(%%%, %); });
    }
)";

        w.write(format,
            type_name,
            type_name,
            bind<write_consume_params>(signature),
            base_param,
            inner_param,
            type_name,
            factory.TypeNamespace(), factory.TypeName(),
            get_name(method),
            bind<write_consume_args>(signature),
            params.empty() ? "" : ", ",
            base_param,
            inner_param);
    }


    void write_static_declaration(writer& w, factory_type const& factory)
    {
        if (!factory.statics)
        {
            return;
        }

        for (auto&& method : factory.type.MethodList())
        {
            method_signature signature{ method };
            auto method_name = get_name(method);
            w.async_types = is_async(method, signature);

            w.write("        static % %(%);\n",
                signature.return_signature(),
                method_name,
                bind<write_consume_params>(signature));

            if (is_add_overload(method))
            {
                auto format = R"(        using %_revoker = impl::factory_event_revoker<%, &impl::abi_t<%>::remove_%>;
        static %_revoker %(auto_revoke_t, %);
)";

                w.write(format,
                    method_name,
                    factory.type,
                    factory.type,
                    method_name,
                    method_name,
                    method_name,
                    bind<write_consume_params>(signature));
            }
        }
    }

    void write_static_definitions(writer& w, MethodDef const& method, std::string_view const& type_name, TypeDef const& factory)
    {
        auto format = R"(    inline % %::%(%)
    {
        %impl::call_factory<%, %>([&](auto&& f) { return f.%(%); });
    }
)";

        method_signature signature{ method };
        auto method_name = get_name(method);
        w.async_types = is_async(method, signature);

        w.write(format,
            signature.return_signature(),
            type_name,
            method_name,
            bind<write_consume_params>(signature),
            signature.return_signature() ? "return " : "",
            type_name,
            factory,
            method_name,
            bind<write_consume_args>(signature));
    }

    void write_class_definitions(writer& w, TypeDef const& type)
    {
        auto type_name = type.TypeName();

        for (auto&& factory : get_factories(type))
        {
            if (factory.activatable)
            {
                if (!factory.type)
                {
                    auto format = R"(    inline %::%() :
        %(impl::call_factory<%>([](auto&& f) { return f.template ActivateInstance<%>(); }))
    {
    }
)";

                    w.write(format,
                        type_name,
                        type_name,
                        type_name,
                        type_name,
                        type_name);
                }
                else
                {
                    w.write_each<write_constructor_definition>(factory.type.MethodList(), type_name, factory.type);
                }
            }
            else if (factory.composable && factory.visible)
            {
                w.write_each<write_composable_constructor_definition>(factory.type.MethodList(), type_name, factory.type);
            }
            else if (factory.statics)
            {
                w.write_each<write_static_definitions>(factory.type.MethodList(), type_name, factory.type);
            }
        }
    }

    void write_fast_declarations(writer& w, TypeDef const& type)
    {
        for (auto&& info : get_fast_interfaces(w, type))
        {
            w.write_each<write_consume_declaration>(info.methods);
        }
    }

    void write_slow_class(writer& w, TypeDef const& type, coded_index<TypeDefOrRef> const& base_type)
    {
        auto type_name = type.TypeName();
        auto factories = get_factories(type);

        auto format = R"(    struct WINRT_EBO % : %%%
    {
        %(std::nullptr_t) noexcept {}
        %(take_ownership_from_abi_t, void* ptr) noexcept : %(take_ownership_from_abi, ptr) {}
%%%    };
)";

        w.write(format,
            type_name,
            base_type,
            bind<write_class_base>(type),
            bind<write_slow_class_requires>(type),
            type_name,
            type_name,
            base_type,
            bind<write_constructor_declarations>(type, factories),
            bind<write_class_usings>(type),
            bind_each<write_static_declaration>(factories));
    }

    void write_fast_class(writer& w, TypeDef const& type)
    {
        auto type_name = type.TypeName();
        auto factories = get_factories(type);
        std::string base_type;

        if (auto base = get_base_class(type))
        {
            base_type = w.write_temp("@::%", base.TypeNamespace(), base.TypeName());
        }
        else
        {
            base_type = "Windows::Foundation::IInspectable";
        }

        auto format = R"(    struct WINRT_EBO % : %%%
    {
        %(std::nullptr_t) noexcept {}
        %(take_ownership_from_abi_t, void* ptr) noexcept : %(take_ownership_from_abi, ptr) {}
%%%%    };
)";

        w.write(format,
            type_name,
            base_type,
            bind<write_class_base>(type),
            bind<write_fast_class_requires>(type),
            type_name,
            type_name,
            base_type,
            bind<write_constructor_declarations>(type, factories),
            bind<write_class_usings>(type),
            bind_each<write_static_declaration>(factories),
            bind<write_fast_declarations>(type));
    }

    void write_static_class(writer& w, TypeDef const& type)
    {
        auto type_name = type.TypeName();
        auto factories = get_factories(type);

        auto format = R"(    struct %
    {
        %() = delete;
%    };
)";

        w.write(format,
            type_name,
            type_name,
            bind_each<write_static_declaration>(factories));
    }

    void write_class(writer& w, TypeDef const& type)
    {
        if (auto default_interface = get_default_interface(type))
        {
            if (is_fast_class(type))
            {
                write_fast_class(w, type);
            }
            else
            {
                write_slow_class(w, type, default_interface);
            }
        }
        else
        {
            write_static_class(w, type);
        }
    }

    void write_std_hash(writer& w, TypeDef const& type)
    {
        auto type_name = type.TypeName();
        auto type_namespace = type.TypeNamespace();

        w.write("    template<> struct hash<winrt::@::%> : winrt::impl::hash_base<winrt::@::%> {};\n",
            type_namespace,
            type_name,
            type_namespace,
            type_name);
    }

    void write_namespace_special(writer& w, std::string_view const& namespace_name, cache const& c)
    {
        if (namespace_name == "Windows.Foundation" && c.find("Windows.Foundation.PropertyValue"))
        {
            w.write(strings::base_reference_produce);
        }
        else if (namespace_name == "Windows.UI.Xaml.Interop")
        {
            w.write(strings::base_xaml_typename);
        }
        else if (namespace_name == "Windows.UI.Core")
        {
            w.write(strings::base_resume_foreground);
        }
    }

    void write_base_fragment(writer& w, std::string_view const& value)
    {
        for (auto&& c : value)
        {
            if (c == '`')
            {
                w.write(settings.root);
            }
            else
            {
                w.write(c);
            }
        }
    }

    void write_component_include(writer& w, TypeDef const& type)
    {
        auto format = R"(#include "%.h"
)";

        if (!get_factories(type).empty())
        {
            w.write(format, get_component_filename(type));
        }
    }

    void write_component_activation(writer& w, TypeDef const& type)
    {
        if (get_factories(type).empty())
        {
            return;
        }

        auto format = R"(        if (requal(name, L"%.%"))
        {
            *factory = winrt::detach_abi(winrt::make<winrt::@::factory_implementation::%>());
            return 0;
        }
)";

        auto type_name = type.TypeName();
        auto type_namespace = type.TypeNamespace();

        w.write(format,
            type_namespace,
            type_name,
            type_namespace,
            type_name);
    }

    void write_component_g_cpp(writer& w, std::vector<TypeDef> const& classes)
    {
        auto format = R"(%
int32_t WINRT_CALL WINRT_CanUnloadNow() noexcept
{
#ifdef _WRL_MODULE_H_
    if (!::Microsoft::WRL::Module<::Microsoft::WRL::InProc>::GetModule().Terminate())
    {
        return 1;
    }
#endif

    if (winrt::get_module_lock())
    {
        return 1;
    }

    winrt::clear_factory_cache();
    return 0;
}

int32_t WINRT_CALL WINRT_GetActivationFactory(void* classId, void** factory) noexcept
{
    try
    {
        *factory = nullptr;
        uint32_t length{};
        wchar_t const* const buffer = WINRT_WindowsGetStringRawBuffer(classId, &length);
        std::wstring_view const name{ buffer, length };

        auto requal = [](std::wstring_view const& left, std::wstring_view const& right) noexcept
        {
            return std::equal(left.rbegin(), left.rend(), right.rbegin(), right.rend());
        };
%
#ifdef _WRL_MODULE_H_
        return ::Microsoft::WRL::Module<::Microsoft::WRL::InProc>::GetModule().GetActivationFactory(static_cast<HSTRING>(classId), reinterpret_cast<::IActivationFactory**>(factory));
#else
        return winrt::hresult_class_not_available(name).to_abi();
#endif
    }
    catch (...) { return winrt::to_hresult(); }
}
)";

        w.write(format,
            bind_each<write_component_include>(classes),
            bind_each<write_component_activation>(classes));
    }

    void write_component_interfaces(writer& w, TypeDef const& type)
    {
        auto interfaces = get_interfaces(w, type);

        if (is_fast_class(type))
        {
            w.write(", fast_interface<@::%>", type.TypeNamespace(), type.TypeName());

            for (auto&&[interface_name, info] : interfaces)
            {
                if (!info.exclusive)
                {
                    w.write(", @", interface_name);
                }
            }
        }
        else
        {
            for (auto&&[interface_name, info] : interfaces)
            {
                w.write(", @", interface_name);
            }
        }
    }

    void write_component_constructor_forwarder(writer& w, MethodDef const& method)
    {
        auto format = R"(        % %(%)
        {
            return make<T>(%);
        }
)";

        method_signature signature{ method };
        w.param_names = true;

        w.write(format,
            signature.return_signature(),
            get_name(method),
            bind<write_implementation_params>(signature),
            bind<write_consume_args>(signature));
    }

        void write_component_static_forwarder(writer& w, MethodDef const& method)
    {
        auto format = R"(        % %(%)
        {
            return T::%(%);
        }
)";

        method_signature signature{ method };
        w.param_names = true;

        w.write(format,
            signature.return_signature(),
            get_name(method),
            bind<write_implementation_params>(signature),
            get_name(method),
            bind<write_consume_args>(signature));
    }

    void write_component_forwarders(writer& w, std::vector<factory_type> const& factories)
    {
        bool default_constructor{};

        for (auto&& factory : factories)
        {
            if (factory.activatable)
            {
                if (!factory.type)
                {
                    default_constructor = true;

                    w.write(R"(        Windows::Foundation::IInspectable ActivateInstance() const
        {
            return make<T>();
        }
)");
                }
                else
                {
                    w.write_each<write_component_constructor_forwarder>(factory.type.MethodList());
                }
            }
            else if (factory.statics)
            {
                w.write_each<write_component_static_forwarder>(factory.type.MethodList());
            }
            else if (factory.composable)
            {
            }
        }

        if (!default_constructor)
        {
            w.write(R"(        [[noreturn]] Windows::Foundation::IInspectable ActivateInstance() const
        {
            throw hresult_not_implemented();
        }
)");
        }
    }

    void write_component_factory_interfaces(writer& w, std::vector<factory_type> const& factories)
    {
        for (auto&& factory : factories)
        {
            if (!factory.type)
            {
                continue;
            }
            
            w.write(", %", factory.type);
        }
    }

    void write_component_g_h(writer& w, TypeDef const& type)
    {
        auto type_name = type.TypeName();
        auto type_namespace = type.TypeNamespace();
        auto interfaces = get_interfaces(w, type);
        auto factories = get_factories(type);
        bool const non_static = !empty(type.InterfaceImpl());

        if (non_static)
        {
            auto format = R"(namespace winrt::@::implementation
{
    template <typename D%, typename... I>
    struct WINRT_EBO %_base : implements<D%%, %I...>%%%
    {
        using base_type = %_base;
        using class_type = @::%;
        using implements_type = typename %_base::implements_type;
        using implements_type::implements_type;
        @
        operator impl::producer_ref<class_type> const() const noexcept
        {
            return { to_abi<default_interface<class_type>>(this) };
        }

        hstring GetRuntimeClassName() const
        {
            return L"%.%";
        }
    %%};
}
)";

            w.write(format,
                type_namespace,
                "",
                type_name,
                bind<write_component_interfaces>(type),
                "",
                "",
                "",
                bind<write_class_base>(type),
                bind<write_class_override_defaults>(interfaces),
                type_name,
                type_namespace,
                type_name,
                type_name,
                "",
                type_namespace,
                type_name,
                "",
                "");
        }

        if (has_factory_members(type))
        {
            auto format = R"(namespace winrt::@::factory_implementation
{
    template <typename D, typename T, typename... I>
    struct WINRT_EBO %T : implements<D, Windows::Foundation::IActivationFactory%, I...>
    {
        using instance_type = @::%;

        hstring GetRuntimeClassName() const
        {
            return L"%.%";
        }
%    };
}
)";

            w.write(format,
                type_namespace,
                type_name,
                bind<write_component_factory_interfaces>(factories),
                type_namespace,
                type_name,
                type_namespace,
                type_name,
                bind<write_component_forwarders>(factories));
        }

        if (non_static)
        {
            auto format = R"(
#if defined(WINRT_FORCE_INCLUDE_%_XAML_G_H) || __has_include("%.xaml.g.h")
#include "%.xaml.g.h"
#else

namespace winrt::@::implementation
{
    template <typename D, typename... I>
    using %T = %_base<D, I...>;
}

#endif
)";

            std::string upper(type_name);
            std::transform(upper.begin(), upper.end(), upper.begin(), [](char c) {return static_cast<char>(::toupper(c)); });

            auto include_path = get_generated_component_filename(type);

            w.write(format,
                upper,
                include_path,
                include_path,
                type_namespace,
                type_name,
                type_name);
        }
    }

    void write_component_base(writer& w, std::string_view const& type_name, bool non_static)
    {
        if (non_static)
        {
            w.write(" : %T<%>", type_name, type_name);
        }
    }

    void write_component_member_declarations(writer& w, TypeDef const& type, std::vector<factory_type> const& factories)
    {
        auto type_name = type.TypeName();

        for (auto&& factory : factories)
        {
            if (factory.activatable)
            {
                if (!factory.type)
                {
                    continue;
                }

                for (auto&& method : factory.type.MethodList())
                {
                    method_signature signature{ method };

                    w.write("        %(%);\n",
                        type_name,
                        bind<write_implementation_params>(signature));
                }
            }
            else if (factory.statics)
            {
                for (auto&& method : factory.type.MethodList())
                {
                    method_signature signature{ method };
                    w.async_types = is_async(method, signature);
                    auto method_name = get_name(method);

                    w.write("        static % %(%)%;\n",
                        signature.return_signature(),
                        method_name,
                        bind<write_implementation_params>(signature),
                        is_noexcept(method) ? " noexcept" : "");
                }
            }
        }

        for (auto&&[interface_name, info] : get_interfaces(w, type))
        {
            for (auto&& method : info.methods)
            {
                method_signature signature{ method };
                w.async_types = is_async(method, signature);
                auto method_name = get_name(method);

                w.write("        % %(%)%;\n",
                    signature.return_signature(),
                    method_name,
                    bind<write_implementation_params>(signature),
                    is_noexcept(method) ? " noexcept" : "");
            }
        }    }

    void write_component_h(writer& w, TypeDef const& type)
    {
        auto type_name = type.TypeName();
        auto type_namespace = type.TypeNamespace();
        auto factories = get_factories(type);
        bool const non_static = !empty(type.InterfaceImpl());

        {
            auto format = R"(#include "%.g.h"

namespace winrt::@::implementation
{
    struct %%
    {
        %() = default;

%    };
}
)";

            w.write(format,
                get_generated_component_filename(type),
                type_namespace,
                type_name,
                bind<write_component_base>(type_name, non_static),
                type_name,
                bind<write_component_member_declarations>(type, factories));

        }

        if (has_factory_members(type))
        {
            auto format = R"(namespace winrt::@::factory_implementation
{
    struct % : %T<%, implementation::%>
    {
    };
}
)";
            w.write(format,
                type_namespace,
                type_name,
                type_name,
                type_name,
                type_name);
        }
    }

    void write_component_member_definitions(writer& w, TypeDef const& type)
    {
        for (auto&&[interface_name, info] : get_interfaces(w, type))
        {
            for (auto&& method : info.methods)
            {
                auto format = R"(    % %::%(%)%
    {
        throw hresult_not_implemented();
    }
)";

                method_signature signature{ method };
                w.async_types = is_async(method, signature);
                auto method_name = get_name(method);

                w.write(format,
                    signature.return_signature(),
                    type.TypeName(),
                    method_name,
                    bind<write_implementation_params>(signature),
                    is_noexcept(method) ? " noexcept" : "");
            }
        }
    }

    void write_component_cpp(writer& w, TypeDef const& type)
    {
        auto format = R"(#include "%.h"

namespace winrt::@::implementation
{
%}
)";

        w.write(format,
            type.TypeName(),
            type.TypeNamespace(),
            bind<write_component_member_definitions>(type));
    }
}
